From 8ce5fc567d6366479f03c6aa2632c61ecdacd162 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Wed, 31 Jan 2024 17:42:54 +0100
Subject: [PATCH 22/49] winegstreamer: Do away with the per-stream condvars and
 use one parser-wide condvar instead.

---
 dlls/winegstreamer/wg_parser.c | 27 ++++++++++-----------------
 1 file changed, 10 insertions(+), 17 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 6f656db98c1..293671a9c08 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -90,6 +90,7 @@ struct wg_parser
     bool err_on, warn_on;
 
     pthread_cond_t read_cond, read_done_cond;
+    pthread_cond_t stream_event_cond;
     struct
     {
         GstBuffer *buffer;
@@ -122,7 +123,6 @@ struct wg_parser_stream
     GstSegment segment;
     struct wg_format preferred_format, current_format, codec_format;
 
-    pthread_cond_t event_cond, event_empty_cond;
     GstBuffer *buffer;
     GstMapInfo map_info;
 
@@ -302,8 +302,7 @@ static NTSTATUS wg_parser_stream_disable(void *args)
     stream->enabled = false;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_cond);
-    pthread_cond_signal(&stream->event_empty_cond);
+    pthread_cond_signal(&parser->stream_event_cond);
     return S_OK;
 }
 
@@ -315,7 +314,7 @@ static GstBuffer *wait_parser_stream_buffer(struct wg_parser *parser, struct wg_
      * must return the buffer. */
 
     while (stream->enabled && !(buffer = stream->buffer) && !stream->eos)
-        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
 
     return buffer;
 }
@@ -329,7 +328,7 @@ static void release_buffer(struct wg_parser *parser, struct wg_parser_stream *st
         stream->buffer = NULL;
     }
 
-    pthread_cond_signal(&stream->event_empty_cond);
+    pthread_cond_signal(&parser->stream_event_cond);
 }
 
 static NTSTATUS wg_parser_stream_get_buffer(void *args)
@@ -741,7 +740,7 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
             pthread_mutex_lock(&parser->mutex);
             stream->eos = true;
             if (stream->enabled)
-                pthread_cond_signal(&stream->event_cond);
+                pthread_cond_signal(&parser->stream_event_cond);
             else
                 pthread_cond_signal(&parser->init_cond);
             pthread_mutex_unlock(&parser->mutex);
@@ -753,7 +752,7 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
             if (stream->enabled)
             {
                 stream->flushing = true;
-                pthread_cond_signal(&stream->event_empty_cond);
+                pthread_cond_signal(&parser->stream_event_cond);
 
                 if (stream->buffer)
                 {
@@ -831,7 +830,7 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
      * implementing a queue object here. */
 
     while (stream->enabled && !stream->flushing && stream->buffer)
-        pthread_cond_wait(&stream->event_empty_cond, &parser->mutex);
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
 
     if (!stream->enabled)
     {
@@ -860,7 +859,7 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
     stream->buffer = buffer;
 
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_cond);
+    pthread_cond_signal(&parser->stream_event_cond);
 
     /* The chain callback is given a reference to the buffer. Transfer that
      * reference to the stream object, which will release it in
@@ -1004,8 +1003,6 @@ static struct wg_parser_stream *create_stream(struct wg_parser *parser, char *id
     stream->number = parser->stream_count;
     stream->no_more_pads = true;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
-    pthread_cond_init(&stream->event_cond, NULL);
-    pthread_cond_init(&stream->event_empty_cond, NULL);
 
     sprintf(pad_name, "qz_sink_%u", parser->stream_count);
     stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
@@ -1037,9 +1034,6 @@ static void free_stream(struct wg_parser_stream *stream)
         stream->buffer = NULL;
     }
 
-    pthread_cond_destroy(&stream->event_cond);
-    pthread_cond_destroy(&stream->event_empty_cond);
-
     for (i = 0; i < ARRAY_SIZE(stream->tags); ++i)
     {
         if (stream->tags[i])
@@ -2096,10 +2090,8 @@ static NTSTATUS wg_parser_disconnect(void *args)
     /* Unblock all of our streams. */
     pthread_mutex_lock(&parser->mutex);
     for (i = 0; i < parser->stream_count; ++i)
-    {
         parser->streams[i]->flushing = true;
-        pthread_cond_signal(&parser->streams[i]->event_empty_cond);
-    }
+    pthread_cond_signal(&parser->stream_event_cond);
     pthread_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
@@ -2275,6 +2267,7 @@ static NTSTATUS wg_parser_create(void *args)
     pthread_cond_init(&parser->init_cond, NULL);
     pthread_cond_init(&parser->read_cond, NULL);
     pthread_cond_init(&parser->read_done_cond, NULL);
+    pthread_cond_init(&parser->stream_event_cond, NULL);
     parser->init_gst = init_funcs[params->type];
     parser->output_compressed = params->output_compressed;
     parser->err_on = params->err_on;
-- 
2.46.0

