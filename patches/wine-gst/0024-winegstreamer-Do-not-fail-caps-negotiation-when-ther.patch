From 689c09959e19f7e9359a8930ac8b4ddd878efc46 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Tue, 19 Mar 2024 10:09:59 +0100
Subject: [PATCH 24/49] winegstreamer: Do not fail caps negotiation when
 there's a concurrent reconfigure.

If wg_parser_stream_enable is called between the time our sink's GST_QUERY_CAPS returns and the time our sink gets the
GST_QUERY_ACCEPT_CAPS query to finalize caps negotiation, GST_QUERY_ACCEPT_CAPS would likely return FALSE because the
caps that are being negotiated would not meet the requirements of the new stream->current_format set by
wg_parser_stream_enable.

Instead, accept both the old and the new format as valid caps in GST_QUERY_ACCEPT_CAPS, but discard buffers until the
correct caps have been negotiated (signalled by a GST_EVENT_CAPS).

Also try to omit the reconfigure event in some cases.
---
 dlls/winegstreamer/wg_parser.c | 72 +++++++++++++++++++++++++++++++---
 1 file changed, 66 insertions(+), 6 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 56acd04d39c..d6e42c3d815 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -121,7 +121,7 @@ struct wg_parser_stream
     GstPad *my_sink;
     GstElement *flip, *decodebin;
     GstSegment segment;
-    struct wg_format preferred_format, current_format, codec_format;
+    struct wg_format preferred_format, current_format, next_format, codec_format;
 
     GstBuffer *buffer;
     GstMapInfo map_info;
@@ -268,16 +268,41 @@ static NTSTATUS wg_parser_stream_get_codec_format(void *args)
     return S_OK;
 }
 
+static BOOL stream_set_next_caps(struct wg_parser_stream *stream, const struct wg_format *format)
+{
+    struct wg_parser *parser = stream->parser;
+
+    while (stream->next_format.major_type != WG_MAJOR_TYPE_UNKNOWN && !parser->error)
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
+
+    if (parser->error)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return E_FAIL;
+    }
+
+    if (!wg_format_compare(&stream->current_format, format)
+            && !(stream->has_caps && wg_format_compare(&stream->preferred_format, format)))
+    {
+        stream->next_format = *format;
+        return stream->has_caps;
+    }
+    else
+        stream->current_format = *format;
+    return FALSE;
+}
+
 static NTSTATUS wg_parser_stream_enable(void *args)
 {
     const struct wg_parser_stream_enable_params *params = args;
     struct wg_parser_stream *stream = get_stream(params->stream);
     const struct wg_format *format = params->format;
     struct wg_parser *parser = stream->parser;
+    BOOL need_reconf = FALSE;
 
     pthread_mutex_lock(&parser->mutex);
 
-    stream->current_format = *format;
+    need_reconf = stream_set_next_caps(stream, format);
     stream->enabled = true;
 
     pthread_mutex_unlock(&parser->mutex);
@@ -285,11 +310,18 @@ static NTSTATUS wg_parser_stream_enable(void *args)
     if (format->major_type == WG_MAJOR_TYPE_VIDEO)
     {
         bool flip = (params->flags & STREAM_ENABLE_FLAG_FLIP_RGB) && (format->u.video.height < 0);
+        GstVideoOrientationMethod old_method = -1, new_method = flip ? GST_VIDEO_ORIENTATION_VERT : GST_VIDEO_ORIENTATION_IDENTITY;
 
-        gst_util_set_object_arg(G_OBJECT(stream->flip), "method", flip ? "vertical-flip" : "none");
+        g_object_get(G_OBJECT(stream->flip), "method", &old_method, NULL);
+        if (new_method != old_method)
+        {
+            g_object_set(G_OBJECT(stream->flip), "method", new_method, NULL);
+            need_reconf = TRUE;
+        }
     }
 
-    push_event(stream->my_sink, gst_event_new_reconfigure());
+    if (need_reconf)
+        push_event(stream->my_sink, gst_event_new_reconfigure());
     return S_OK;
 }
 
@@ -301,6 +333,7 @@ static NTSTATUS wg_parser_stream_disable(void *args)
     pthread_mutex_lock(&parser->mutex);
     stream->enabled = false;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
+    stream->next_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_broadcast(&parser->stream_event_cond);
     return S_OK;
@@ -792,6 +825,17 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
             pthread_mutex_lock(&parser->mutex);
             wg_format_from_caps(&stream->preferred_format, caps);
             stream->has_caps = true;
+            if (stream->next_format.major_type != WG_MAJOR_TYPE_UNKNOWN)
+            {
+                if (!wg_format_compare(&stream->preferred_format, &stream->next_format))
+                    push_event(stream->my_sink, gst_event_new_reconfigure());
+                else
+                {
+                    stream->current_format = stream->next_format;
+                    stream->next_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
+                    pthread_cond_broadcast(&parser->stream_event_cond);
+                }
+            }
             pthread_mutex_unlock(&parser->mutex);
             pthread_cond_signal(&parser->init_cond);
             break;
@@ -820,6 +864,14 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
 
     pthread_mutex_lock(&parser->mutex);
 
+    if (stream->next_format.major_type != WG_MAJOR_TYPE_UNKNOWN)
+    {
+        GST_DEBUG("Stream is changing format; discarding buffer.");
+        pthread_mutex_unlock(&parser->mutex);
+        gst_buffer_unref(buffer);
+        return GST_FLOW_OK;
+    }
+
     if (!stream->has_buffer)
     {
         stream->has_buffer = true;
@@ -923,7 +975,9 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             gst_query_parse_caps(query, &filter);
 
             pthread_mutex_lock(&parser->mutex);
-            if (stream->current_format.major_type != WG_MAJOR_TYPE_UNKNOWN)
+            if (stream->next_format.major_type != WG_MAJOR_TYPE_UNKNOWN)
+                caps = wg_format_to_caps(&stream->next_format);
+            else if (stream->current_format.major_type != WG_MAJOR_TYPE_UNKNOWN)
                 caps = wg_format_to_caps(&stream->current_format);
             else
                 caps = get_supported_formats();
@@ -959,7 +1013,8 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 
             pthread_mutex_lock(&parser->mutex);
 
-            if (stream->current_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+            if (stream->current_format.major_type == WG_MAJOR_TYPE_UNKNOWN ||
+                    stream->next_format.major_type != WG_MAJOR_TYPE_UNKNOWN)
             {
                 pthread_mutex_unlock(&parser->mutex);
                 gst_query_set_accept_caps_result(query, TRUE);
@@ -969,6 +1024,8 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             gst_query_parse_accept_caps(query, &caps);
             wg_format_from_caps(&format, caps);
             ret = wg_format_compare(&format, &stream->current_format);
+            if (!ret)
+                ret = wg_format_compare(&format, &stream->next_format);
 
             pthread_mutex_unlock(&parser->mutex);
 
@@ -1003,6 +1060,7 @@ static struct wg_parser_stream *create_stream(struct wg_parser *parser, char *id
     stream->number = parser->stream_count;
     stream->no_more_pads = true;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
+    stream->next_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
 
     sprintf(pad_name, "qz_sink_%u", parser->stream_count);
     stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
@@ -1660,6 +1718,7 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         parser->error = true;
         pthread_mutex_unlock(&parser->mutex);
         pthread_cond_signal(&parser->init_cond);
+        pthread_cond_broadcast(&parser->stream_event_cond);
         break;
 
     case GST_MESSAGE_WARNING:
@@ -1690,6 +1749,7 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
                 GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
                 parser->error = true;
                 pthread_cond_signal(&parser->init_cond);
+                pthread_cond_broadcast(&parser->stream_event_cond);
             }
             pthread_mutex_unlock(&parser->mutex);
         }
-- 
2.46.0

