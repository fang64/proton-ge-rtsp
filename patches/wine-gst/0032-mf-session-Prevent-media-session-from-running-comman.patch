From c0a51e37cb3ce529f693d0732a836d758b71dd60 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Mon, 29 Jul 2024 04:21:03 +0200
Subject: [PATCH 32/49] mf/session: Prevent media session from running commands
 concurrently.

CW-Bug-Id: #24115
---
 dlls/mf/session.c | 105 ++++++++++++++++++++++++++++------------------
 1 file changed, 64 insertions(+), 41 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 752bdcf1c21..e119755f732 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -220,6 +220,7 @@ enum presentation_flags
     SESSION_FLAG_END_OF_PRESENTATION = 0x10,
     SESSION_FLAG_PENDING_RATE_CHANGE = 0x20,
     SESSION_FLAG_PENDING_COMMAND = 0x40,
+    SESSION_FLAG_QUEUED_COMMAND = 0x80,
 };
 
 struct media_session
@@ -455,6 +456,33 @@ static HRESULT session_is_shut_down(struct media_session *session)
     return session->state == SESSION_STATE_SHUT_DOWN ? MF_E_SHUTDOWN : S_OK;
 }
 
+static void session_schedule_command(struct media_session *session)
+{
+    struct session_op *op;
+    struct list *e;
+
+    if (session->presentation.flags & (SESSION_FLAG_PENDING_COMMAND | SESSION_FLAG_QUEUED_COMMAND))
+    {
+        TRACE("not queueing: flags %x\n", session->presentation.flags);
+        return;
+    }
+
+    if (session->state != SESSION_STATE_STOPPED && session->state != SESSION_STATE_STARTED &&
+        session->state != SESSION_STATE_PAUSED && session->state != SESSION_STATE_CLOSED &&
+        session->state != SESSION_STATE_SHUT_DOWN)
+    {
+        TRACE("not queueing: state %x\n", session->state);
+        return;
+    }
+
+    if ((e = list_head(&session->commands)))
+    {
+        op = LIST_ENTRY(e, struct session_op, entry);
+        MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
+        session->presentation.flags |= SESSION_FLAG_QUEUED_COMMAND;
+    }
+}
+
 static HRESULT session_submit_command(struct media_session *session, struct session_op *op)
 {
     HRESULT hr;
@@ -464,13 +492,12 @@ static HRESULT session_submit_command(struct media_session *session, struct sess
     EnterCriticalSection(&session->cs);
     if (SUCCEEDED(hr = session_is_shut_down(session)))
     {
-        if (list_empty(&session->commands) && !(session->presentation.flags & SESSION_FLAG_PENDING_COMMAND))
-            hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
         if (op->command == SESSION_CMD_SHUTDOWN)
             list_add_head(&session->commands, &op->entry);
         else
             list_add_tail(&session->commands, &op->entry);
         IUnknown_AddRef(&op->IUnknown_iface);
+        session_schedule_command(session);
     }
     LeaveCriticalSection(&session->cs);
 
@@ -953,17 +980,9 @@ static struct topo_node *session_get_topo_node_output(const struct media_session
 
 static void session_command_complete(struct media_session *session)
 {
-    struct session_op *op;
-    struct list *e;
-
-    session->presentation.flags &= ~SESSION_FLAG_PENDING_COMMAND;
-
+    session->presentation.flags &= ~(SESSION_FLAG_PENDING_COMMAND | SESSION_FLAG_QUEUED_COMMAND);
     /* Submit next command. */
-    if ((e = list_head(&session->commands)))
-    {
-        op = LIST_ENTRY(e, struct session_op, entry);
-        MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
-    }
+    session_schedule_command(session);
 }
 
 static void session_command_complete_with_event(struct media_session *session, MediaEventType event,
@@ -995,21 +1014,11 @@ static HRESULT session_subscribe_sources(struct media_session *session)
     return hr;
 }
 
-static void session_set_source_output_nodes_seeking(struct media_session *session)
+static void session_set_state(struct media_session *session, enum session_state new_state)
 {
-    struct media_source *source;
-    struct topo_node *node;
-
-    LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
-    {
-        source->state = OBJ_STATE_SEEKING;
-    }
-
-    LIST_FOR_EACH_ENTRY(node, &session->presentation.nodes, struct topo_node, entry)
-    {
-        if (node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || node->type == MF_TOPOLOGY_OUTPUT_NODE)
-            node->state = OBJ_STATE_SEEKING;
-    }
+    TRACE("setting state to %d\n", new_state);
+    session->state = new_state;
+    session_schedule_command(session);
 }
 
 static void session_start(struct media_session *session, const GUID *time_format, const PROPVARIANT *start_position)
@@ -1034,6 +1043,9 @@ static void session_start(struct media_session *session, const GUID *time_format
             /* fallthrough */
         case SESSION_STATE_PAUSED:
         case SESSION_STATE_STARTED:
+        {
+            enum session_state new_state = SESSION_STATE_STARTED;
+
             if (session->state == SESSION_STATE_STARTED && !(session->caps & MFSESSIONCAP_SEEK))
             {
                 WARN("Seeking is not supported for this session.\n");
@@ -1067,6 +1079,12 @@ static void session_start(struct media_session *session, const GUID *time_format
                     session_command_complete_with_event(session, MESessionStarted, hr, NULL);
                     return;
                 }
+
+                if (start_position->vt != VT_EMPTY)
+                    source->state = OBJ_STATE_SEEKING;
+
+                if (source->state != OBJ_STATE_STARTED)
+                    new_state = SESSION_STATE_STARTING_SOURCES;
             }
 
             LIST_FOR_EACH_ENTRY(topo_node, &session->presentation.nodes, struct topo_node, entry)
@@ -1079,6 +1097,11 @@ static void session_start(struct media_session *session, const GUID *time_format
                         stream->draining = FALSE;
                     }
                 }
+                else if (start_position->vt != VT_EMPTY)
+                {
+                    if (topo_node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || topo_node->type == MF_TOPOLOGY_OUTPUT_NODE)
+                        topo_node->state = OBJ_STATE_SEEKING;
+                }
             }
 
             if (session->state == SESSION_STATE_STARTED)
@@ -1092,11 +1115,11 @@ static void session_start(struct media_session *session, const GUID *time_format
                     else if (node->type == MF_TOPOLOGY_TRANSFORM_NODE)
                         IMFTransform_ProcessMessage(node->object.transform, MFT_MESSAGE_COMMAND_FLUSH, 0);
                 }
-
-                session_set_source_output_nodes_seeking(session);
             }
-            session->state = SESSION_STATE_STARTING_SOURCES;
+
+            session_set_state(session, new_state);
             break;
+        }
         default:
             session_command_complete_with_event(session, MESessionStarted, MF_E_INVALIDREQUEST, NULL);
             break;
@@ -1110,7 +1133,7 @@ static void session_set_started(struct media_session *session)
     unsigned int caps;
     DWORD flags;
 
-    session->state = SESSION_STATE_STARTED;
+    session_set_state(session, SESSION_STATE_STARTED);
 
     caps = session->caps | MFSESSIONCAP_PAUSE;
 
@@ -1142,7 +1165,7 @@ static void session_set_paused(struct media_session *session, unsigned int state
     /* Failed event status could indicate a failure during normal transition to paused state,
        or an attempt to pause from invalid initial state. To finalize failed transition in the former case,
        state is still forced to PAUSED, otherwise previous state is retained. */
-    if (state != ~0u) session->state = state;
+    if (state != ~0u) session_set_state(session, state);
     if (SUCCEEDED(status))
         session_set_caps(session, session->caps & ~MFSESSIONCAP_PAUSE);
     session_command_complete_with_event(session, MESessionPaused, status, NULL);
@@ -1150,7 +1173,7 @@ static void session_set_paused(struct media_session *session, unsigned int state
 
 static void session_set_closed(struct media_session *session, HRESULT status)
 {
-    session->state = SESSION_STATE_CLOSED;
+    session_set_state(session, SESSION_STATE_CLOSED);
     if (SUCCEEDED(status))
         session_set_caps(session, session->caps & ~(MFSESSIONCAP_START | MFSESSIONCAP_SEEK));
     session_command_complete_with_event(session, MESessionClosed, status, NULL);
@@ -1167,7 +1190,7 @@ static void session_pause(struct media_session *session)
 
             /* Transition in two steps - pause the clock, wait for sinks, then pause sources. */
             if (SUCCEEDED(hr = IMFPresentationClock_Pause(session->clock)))
-                session->state = SESSION_STATE_PAUSING_SINKS;
+                session_set_state(session, SESSION_STATE_PAUSING_SINKS);
             state = SESSION_STATE_PAUSED;
 
             break;
@@ -1205,7 +1228,7 @@ static void session_set_stopped(struct media_session *session, HRESULT status)
     MediaEventType event_type;
     IMFMediaEvent *event;
 
-    session->state = SESSION_STATE_STOPPED;
+    session_set_state(session, SESSION_STATE_STOPPED);
     event_type = session->presentation.flags & SESSION_FLAG_END_OF_PRESENTATION ? MESessionEnded : MESessionStopped;
 
     if (SUCCEEDED(MFCreateMediaEvent(event_type, &GUID_NULL, status, NULL, &event)))
@@ -1230,7 +1253,7 @@ static void session_stop(struct media_session *session)
             /* Transition in two steps - stop the clock, wait for sinks, then stop sources. */
             IMFPresentationClock_GetTime(session->clock, &session->presentation.clock_stop_time);
             if (SUCCEEDED(hr = IMFPresentationClock_Stop(session->clock)))
-                session->state = SESSION_STATE_STOPPING_SINKS;
+                session_set_state(session, SESSION_STATE_STOPPING_SINKS);
             else
                 session_set_stopped(session, hr);
 
@@ -1252,7 +1275,7 @@ static HRESULT session_finalize_sinks(struct media_session *session)
     HRESULT hr = S_OK;
 
     session->presentation.flags &= ~SESSION_FLAG_FINALIZE_SINKS;
-    session->state = SESSION_STATE_FINALIZING_SINKS;
+    session_set_state(session, SESSION_STATE_FINALIZING_SINKS);
 
     LIST_FOR_EACH_ENTRY(sink, &session->presentation.sinks, struct media_sink, entry)
     {
@@ -1288,7 +1311,7 @@ static void session_close(struct media_session *session)
         case SESSION_STATE_PAUSED:
             session->presentation.flags |= SESSION_FLAG_FINALIZE_SINKS;
             if (SUCCEEDED(hr = IMFPresentationClock_Stop(session->clock)))
-                session->state = SESSION_STATE_STOPPING_SINKS;
+                session_set_state(session, SESSION_STATE_STOPPING_SINKS);
             break;
         default:
             hr = MF_E_INVALIDREQUEST;
@@ -2402,7 +2425,7 @@ static HRESULT WINAPI mfsession_Shutdown(IMFMediaSession *iface)
     EnterCriticalSection(&session->cs);
     if (SUCCEEDED(hr = session_is_shut_down(session)))
     {
-        session->state = SESSION_STATE_SHUT_DOWN;
+        session_set_state(session, SESSION_STATE_SHUT_DOWN);
         IMFMediaEventQueue_Shutdown(session->event_queue);
         if (session->quality_manager)
             IMFQualityManager_Shutdown(session->quality_manager);
@@ -3117,10 +3140,10 @@ static void session_set_source_object_state(struct media_session *session, IUnkn
                         }
                     }
                 }
-                session->state = SESSION_STATE_PREROLLING_SINKS;
+                session_set_state(session, SESSION_STATE_PREROLLING_SINKS);
             }
             else if (SUCCEEDED(session_start_clock(session)))
-                session->state = SESSION_STATE_STARTING_SINKS;
+                session_set_state(session, SESSION_STATE_STARTING_SINKS);
 
             break;
         case SESSION_STATE_PAUSING_SOURCES:
@@ -3182,7 +3205,7 @@ static void session_set_sink_stream_state(struct media_session *session, IMFStre
                 break;
 
             if (SUCCEEDED(session_start_clock(session)))
-                session->state = SESSION_STATE_STARTING_SINKS;
+                session_set_state(session, SESSION_STATE_STARTING_SINKS);
             break;
         case SESSION_STATE_STARTING_SINKS:
             if (!session_is_output_nodes_state(session, OBJ_STATE_STARTED))
-- 
2.47.0

