From 7e6827b0d6e4609485224e3e4a454072fea256c8 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Tue, 19 Mar 2024 10:09:59 +0100
Subject: [PATCH 23/46] winegstreamer: Do not fail caps negotiation when
 there's a concurrent reconfigure.

If wg_parser_stream_enable is called between the time our sink's GST_QUERY_CAPS returns and the time our sink gets the
GST_QUERY_ACCEPT_CAPS query to finalize caps negotiation, GST_QUERY_ACCEPT_CAPS would likely return FALSE because the
caps that are being negotiated would not meet the requirements of the new stream->current_format set by
wg_parser_stream_enable.

Instead, accept both the old and the new format as valid caps in GST_QUERY_ACCEPT_CAPS, but discard buffers until the
correct caps have been negotiated (signalled by a GST_EVENT_CAPS).

Also try to omit the reconfigure event in some cases.
---
 dlls/winegstreamer/wg_parser.c | 107 ++++++++++++++++++++++++++++++---
 1 file changed, 99 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index ef89d506bf6..11b4d4f915a 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -124,6 +124,7 @@ struct wg_parser_stream
     GstCaps *codec_caps;
     GstCaps *current_caps;
     GstCaps *desired_caps;
+    GstCaps *next_desired_caps;
 
     GstBuffer *buffer;
     GstMapInfo map_info;
@@ -298,16 +299,53 @@ static NTSTATUS wg_parser_stream_get_codec_format(void *args)
     return S_OK;
 }
 
+static BOOL stream_set_next_caps(struct wg_parser_stream *stream, GstCaps *caps)
+{
+    struct wg_parser *parser = stream->parser;
+
+    while (stream->next_desired_caps && !parser->error)
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
+
+    if (parser->error)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return E_FAIL;
+    }
+
+    if (!(stream->current_caps && gst_caps_is_equal(stream->current_caps, caps)))
+    {
+        if (stream->desired_caps)
+        {
+            if (!gst_caps_is_equal(stream->desired_caps, caps))
+            {
+                stream->next_desired_caps = caps;
+                return !!stream->current_caps;
+            }
+        }
+        else
+            stream->desired_caps = caps;
+        return TRUE;
+    }
+    else if (!(stream->desired_caps && gst_caps_is_equal(stream->desired_caps, caps)))
+    {
+        stream->desired_caps = caps;
+        return FALSE;
+    }
+    gst_caps_unref(caps);
+    return FALSE;
+}
+
 static NTSTATUS wg_parser_stream_enable(void *args)
 {
     const struct wg_parser_stream_enable_params *params = args;
     struct wg_parser_stream *stream = get_stream(params->stream);
     const struct wg_format *format = params->format;
     struct wg_parser *parser = stream->parser;
+    BOOL need_reconf;
 
     pthread_mutex_lock(&parser->mutex);
 
-    stream->desired_caps = wg_format_to_caps(format);
+    need_reconf = stream_set_next_caps(stream, wg_format_to_caps(format));
     stream->enabled = true;
 
     pthread_mutex_unlock(&parser->mutex);
@@ -315,11 +353,18 @@ static NTSTATUS wg_parser_stream_enable(void *args)
     if (format->major_type == WG_MAJOR_TYPE_VIDEO)
     {
         bool flip = (format->u.video.height < 0);
+        GstVideoOrientationMethod old_method = -1, new_method = flip ? GST_VIDEO_ORIENTATION_VERT : GST_VIDEO_ORIENTATION_IDENTITY;
 
-        gst_util_set_object_arg(G_OBJECT(stream->flip), "method", flip ? "vertical-flip" : "none");
+        g_object_get(G_OBJECT(stream->flip), "method", &old_method, NULL);
+        if (new_method != old_method)
+        {
+            g_object_set(G_OBJECT(stream->flip), "method", new_method, NULL);
+            need_reconf = TRUE;
+        }
     }
 
-    push_event(stream->my_sink, gst_event_new_reconfigure());
+    if (need_reconf)
+        push_event(stream->my_sink, gst_event_new_reconfigure());
     return S_OK;
 }
 
@@ -328,10 +373,11 @@ static NTSTATUS wg_parser_stream_enable_type(void *args)
     const struct wg_parser_stream_enable_type_params *params = args;
     struct wg_parser_stream *stream = get_stream(params->stream);
     struct wg_parser *parser = stream->parser;
+    BOOL need_reconf;
 
     pthread_mutex_lock(&parser->mutex);
 
-    stream->desired_caps = caps_from_media_type(&params->media_type);
+    need_reconf = stream_set_next_caps(stream, caps_from_media_type(&params->media_type));
     stream->enabled = true;
 
     pthread_mutex_unlock(&parser->mutex);
@@ -339,11 +385,18 @@ static NTSTATUS wg_parser_stream_enable_type(void *args)
     if (IsEqualGUID(&params->media_type.major, &MEDIATYPE_Video) && stream->flip)
     {
         bool flip = !!(params->media_type.u.video->videoInfo.VideoFlags & MFVideoFlag_BottomUpLinearRep);
+        GstVideoOrientationMethod old_method = -1, new_method = flip ? GST_VIDEO_ORIENTATION_VERT : GST_VIDEO_ORIENTATION_IDENTITY;
 
-        gst_util_set_object_arg(G_OBJECT(stream->flip), "method", flip ? "vertical-flip" : "none");
+        g_object_get(G_OBJECT(stream->flip), "method", &old_method, NULL);
+        if (new_method != old_method)
+        {
+            g_object_set(G_OBJECT(stream->flip), "method", new_method, NULL);
+            need_reconf = TRUE;
+        }
     }
 
-    push_event(stream->my_sink, gst_event_new_reconfigure());
+    if (need_reconf)
+        push_event(stream->my_sink, gst_event_new_reconfigure());
     return S_OK;
 }
 
@@ -359,6 +412,11 @@ static NTSTATUS wg_parser_stream_disable(void *args)
         gst_caps_unref(stream->desired_caps);
         stream->desired_caps = NULL;
     }
+    if (stream->next_desired_caps)
+    {
+        gst_caps_unref(stream->next_desired_caps);
+        stream->next_desired_caps = NULL;
+    }
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_broadcast(&parser->stream_event_cond);
     return S_OK;
@@ -886,6 +944,16 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
             gst_event_parse_caps(event, &caps);
             pthread_mutex_lock(&parser->mutex);
             stream->current_caps = gst_caps_ref(caps);
+            if (stream->next_desired_caps)
+            {
+                if (!gst_caps_can_intersect(stream->current_caps, stream->next_desired_caps))
+                    push_event(stream->my_sink, gst_event_new_reconfigure());
+                else
+                {
+                    stream->next_desired_caps = NULL;
+                    pthread_cond_broadcast(&parser->stream_event_cond);
+                }
+            }
             pthread_mutex_unlock(&parser->mutex);
             pthread_cond_signal(&parser->init_cond);
             break;
@@ -914,6 +982,14 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
 
     pthread_mutex_lock(&parser->mutex);
 
+    if (stream->next_desired_caps)
+    {
+        GST_DEBUG("Stream is changing format; discarding buffer.");
+        pthread_mutex_unlock(&parser->mutex);
+        gst_buffer_unref(buffer);
+        return GST_FLOW_OK;
+    }
+
     if (!stream->has_buffer)
     {
         stream->has_buffer = true;
@@ -980,7 +1056,15 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             gst_query_parse_caps(query, &filter);
 
             pthread_mutex_lock(&parser->mutex);
-            if (!stream->desired_caps || !(caps = gst_caps_copy(stream->desired_caps)))
+            if (stream->next_desired_caps)
+            {
+                if (!(caps = gst_caps_copy(stream->next_desired_caps)))
+                {
+                    pthread_mutex_unlock(&parser->mutex);
+                    return FALSE;
+                }
+            }
+            else if (!stream->desired_caps || !(caps = gst_caps_copy(stream->desired_caps)))
             {
                 pthread_mutex_unlock(&parser->mutex);
                 return FALSE;
@@ -1014,7 +1098,7 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 
             pthread_mutex_lock(&parser->mutex);
 
-            if (!stream->desired_caps)
+            if (!stream->desired_caps || !stream->next_desired_caps)
             {
                 pthread_mutex_unlock(&parser->mutex);
                 gst_query_set_accept_caps_result(query, TRUE);
@@ -1025,6 +1109,11 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             wg_format_from_caps(&format, caps);
             wg_format_from_caps(&current_format, stream->desired_caps);
             ret = wg_format_compare(&format, &current_format);
+            if (!ret)
+            {
+                wg_format_from_caps(&current_format, stream->next_desired_caps);
+                ret = wg_format_compare(&format, &current_format);
+            }
 
             pthread_mutex_unlock(&parser->mutex);
 
@@ -1711,6 +1800,7 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         parser->error = true;
         pthread_mutex_unlock(&parser->mutex);
         pthread_cond_signal(&parser->init_cond);
+        pthread_cond_broadcast(&parser->stream_event_cond);
         break;
 
     case GST_MESSAGE_WARNING:
@@ -1741,6 +1831,7 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
                 GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
                 parser->error = true;
                 pthread_cond_signal(&parser->init_cond);
+                pthread_cond_broadcast(&parser->stream_event_cond);
             }
             pthread_mutex_unlock(&parser->mutex);
         }
-- 
2.46.0

